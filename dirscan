#!/usr/bin/env python3

import argparse
import math
import multiprocessing as mp
import os, pwd
import re
import sys
import bisect
from multiprocessing import Process, Queue
from prettytable import PrettyTable

units = {"B": 1, "KB": 2 ** 10, "MB": 2 ** 20, "GB": 2 ** 30, "TB": 2 ** 40}
raw_bins = [4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152]

def human_to_byte(size_input) -> int:
    size_input = size_input.upper()
    if not re.match(r' ', size_input):
        size_input = re.sub(r'([KMGT]?B)', r' \1', size_input)
    number, unit = [string.strip() for string in size_input.split()]
    return int(float(number) * units[unit])


def byte_to_human(size_input) -> str:
    size_input = abs(size_input)
    if size_input == 0:
        return "0 B"
    p = int(math.floor(math.log(size_input, 2) / 10))
    return "%0.2f%s" % (size_input / math.pow(1024, p),
                         ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'][p])


def calc_percentage(num1, num2) -> int:
    percentage = round(num1 / num2) * 100
    return percentage


def merge_user_lists(list_dict_users) -> dict:
    merged_user_dict = {}
    for list_users in list_dict_users:
        for user_dict in list_users:
            for user_id in user_dict:
                if user_id in merged_user_dict:
                    merged_user_dict[user_id] = {
                        'filecount': merged_user_dict[user_id]['filecount'] + user_dict[user_id]['filecount'],
                        'filesize': merged_user_dict[user_id]['filesize'] + user_dict[user_id]['filesize']}
                else:
                    merged_user_dict[user_id] = {'filecount': user_dict[user_id]['filecount'],
                                                 'filesize': user_dict[user_id]['filesize']}
    return merged_user_dict


def scan_directory(q, subdirectories_to_scan) -> None:
    file_count = 0
    size_bytes = 0
    subdir_count = 0
    list_users = []
    user_stats = {}
    dict_file_histogram = {
        0: ['4kiB', 0],
        1: ['16kiB', 0],
        2: ['32kiB', 0],
        3: ['64kiB', 0],
        4: ['128kiB', 0],
        5: ['256kiB', 0],
        6: ['512kiB', 0],
        7: ['1MiB', 0],
        8: ['2MiB', 0]
    }

    for subdir in subdirectories_to_scan:
        subfolders, file_list = dir_and_file_scan(subdir)
        file_count += len(file_list)
        subdir_count += 1
        for filename in file_list:
            try:
                file_stat = os.stat(filename)
                size_bytes += file_stat.st_size
                index = bisect.bisect(raw_bins, file_stat.st_size)
                if index > 8:
                    index = 8
                dict_file_histogram[index][1] = dict_file_histogram[index][1] + 1
                if file_stat.st_uid in user_stats:
                    user_stats[file_stat.st_uid] = {'filecount': user_stats[file_stat.st_uid]['filecount'] + 1,
                                                    'filesize': user_stats[file_stat.st_uid]['filesize']
                                                                + file_stat.st_size}
                else:
                    user_stats[file_stat.st_uid] = {'filecount': 1, 'filesize': file_stat.st_size}
            except:
                pass

    list_users.append(user_stats)
    q.put([subdir_count, size_bytes, file_count, list_users, dict_file_histogram])


def dir_and_file_scan(subdir) -> tuple:
    subfolders, files = [], []
    try:
        for f in os.scandir(subdir):
            if f.is_dir(follow_symlinks=False):
                subfolders.append(f.path)
            if f.is_file(follow_symlinks=False):
                files.append(f.path)
    except:
        pass
    for subdir in list(subfolders):
        sf, f = dir_and_file_scan(subdir)
        subfolders.extend(sf)
        files.extend(f)
    return subfolders, files


if __name__ == '__main__':

    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument("-p", "--path", default=os.getcwd(),
                            help="Path to scan. Default is the current working directory.")
    #arg_parser.add_argument("-p", "--path", default='/home/andreas/list_dir_test',
    #                        help="Path to scan. Default is the current working directory.")
    args = arg_parser.parse_args()
    scan_path = args.path
    directory_to_scan = scan_path

    raw_bins.sort()

    list_directories = []

    for f in os.scandir(directory_to_scan):
        if f.is_dir(follow_symlinks=False):
            list_directories.append(f.path)
    list_directories.append(directory_to_scan)
    list_directories.remove(scan_path)

    print("Starting scan in: %s" % directory_to_scan)

    if len(list_directories) < 1:
        print("No subdirectories found to scan in: %s" % directory_to_scan)
        sys.exit(1)
    elif len(list_directories) <= mp.cpu_count():
        chunk_size = 1
    else:
        chunk_size = math.ceil(len(list_directories) / mp.cpu_count())

    start = 0
    queue = Queue()
    num_procs = 0
    sub_procs = []
    files = 0
    size = 0
    sub_dirs = 0
    result_list = []

    print("Found %d subdirectories in: %s" % (len(list_directories), directory_to_scan))
    print("Found %d available CPUs." % mp.cpu_count())
    print("Will start %d scan processes and delegate chunks of %d subdirectories to each process." % (mp.cpu_count(),
                                                                                                      chunk_size))

    while start < len(list_directories):
        proc = Process(target=scan_directory, args=(queue, list_directories[start:start + chunk_size]))
        num_procs += 1
        proc.start()
        start += chunk_size
        sub_procs.append(proc)

    for i in range(num_procs):
        result_list.append(queue.get())

    while sub_procs:
        sub_procs.pop().join()

    list_user_data = []
    list_file_histograms = []

    for result in result_list:
        size = size + result[1]
        files = files + result[2]
        list_user_data.append(result[3])
        list_file_histograms.append(result[4])

    print('\033[1m' + "Total:", byte_to_human(size), "- Files:", str(files) + '\033[0m')

    users_data = merge_user_lists(list_user_data)

    output_table = PrettyTable()
    output_table.field_names = ["User", "Capacity", "Files"]

    for user in users_data:
        output_table.add_row([pwd.getpwuid(user)[0], byte_to_human(users_data[user]['filesize']), users_data[user]['filecount']])

    output_table.align["User"] = "l"
    output_table.align["Capacity"] = "r"
    output_table.align["Files"] = "r"

    print(output_table)
